{
  "visual": {
    "name": "ClusteringUsingOPTICSByMAQSoftware",
    "displayName": "Clustering using OPTICS by MAQ Software",
    "guid": "ClusteringUsingOPTICSCAD9384DAA1042E78771F55A0BD811D8",
    "visualClassName": "ClusteringUsingOPTICS",
    "version": "3.0.5",
    "description": "OPTICS based clustering algorithm to analyze groups and hierarchies within a group.â€‹",
    "supportUrl": "https://github.com/maqsoftware/PowerBI-visuals/issues",
    "gitHubUrl": "https://github.com/maqsoftware/PowerBI-visuals/"
  },
  "apiVersion": "2.1.0",
  "author": {
    "name": "MAQ Software",
    "email": "support@maqsoftware.com"
  },
  "assets": {
    "icon": "assets/icon.png"
  },
  "externalJS": [
    "node_modules/powerbi-visuals-utils-dataviewutils/lib/index.js"
  ],
  "style": "style/visual.less",
  "capabilities": {
    "dataRoles": [
      {
        "displayName": "X values",
        "kind": "GroupingOrMeasure",
        "name": "Value1"
      },
      {
        "displayName": "Y values",
        "kind": "GroupingOrMeasure",
        "name": "Value2"
      },
      {
        "displayName": "Tooltip",
        "kind": "GroupingOrMeasure",
        "name": "Tooltip"
      }
    ],
    "dataViewMappings": [
      {
        "conditions": [
          {
            "Value1": {
              "max": 6
            },
            "Value2": {
              "max": 6
            },
            "Tooltip": {
              "max": 1
            }
          }
        ],
        "scriptResult": {
          "dataInput": {
            "table": {
              "rows": {
                "select": [
                  {
                    "for": {
                      "in": "Value1"
                    }
                  },
                  {
                    "for": {
                      "in": "Value2"
                    }
                  },
                  {
                    "for": {
                      "in": "Tooltip"
                    }
                  }
                ],
                "dataReductionAlgorithm": {
                  "top": {
                    "count": 10000
                  }
                }
              }
            }
          },
          "script": {
            "scriptProviderDefault": "R",
            "scriptOutputType": "html",
            "source": {
              "objectName": "rcv_script",
              "propertyName": "source"
            },
            "provider": {
              "objectName": "rcv_script",
              "propertyName": "provider"
            },
            "scriptSourceDefault": "# Copyright (c) MAQ Software.  All rights reserved.\n\n# Third Party Programs. This software enables you to obtain software applications from other sources.\n# Those applications are offered and distributed by third parties under their own license terms.\n# MAQ Software is not developing, distributing or licensing those applications to you, but instead,\n# as a convenience, enables you to use this software to obtain those applications directly from\n# the application providers.\n# By using the software, you acknowledge and agree that you are obtaining the applications directly\n# from the third party providers and under separate license terms, and that it is your responsibility to locate,\n# understand and comply with those license terms.\n# Microsoft grants you no license rights for third-party software or applications that is obtained using this software.\n\n#\n# WARNINGS:\n#\n# CREATION DATE: 06/12/2017\n#\n# LAST UPDATE: --/--/---\n#\n# VERSION: 3.0.0\n#\n# R VERSION TESTED: 3.4.2\n#\n# AUTHOR: MAQ Software\n\n############### Utility functions ###############\nlibraryRequireInstall = function(packageName, ...)\n{\n  if(!require(packageName, character.only = TRUE)) \n    warning(paste(\"*** The package: '\", packageName, \"' was not installed ***\", sep=\"\"))\n}\n\nlibraryRequireInstall(\"XML\")\nlibraryRequireInstall(\"htmlwidgets\")\n\ninternalSaveWidget <- function(widget, fname)\n{\n  tempFname = paste(fname, \".tmp\", sep=\"\")\n  htmlwidgets::saveWidget(widget, file = tempFname, selfcontained = FALSE)\n  FlattenHTML(tempFname, fname)\n}\n\nFlattenHTML <- function(fnameIn, fnameOut)\n{\n  # Read and parse HTML file\n  # Embed all js and css files into one unified file\n  \n  if(!file.exists(fnameIn))\n    return(FALSE)\n  \n  dir = dirname(fnameIn)\n  html = htmlTreeParse(fnameIn, useInternal = TRUE)\n  top = xmlRoot(html)\n  \n  # extract all <script> tags with src value\n  srcNode=getNodeSet(top, '//script[@src]')\n  for (node in srcNode)\n  {\n    b = xmlAttrs(node)\n    fname = file.path(dir, b['src'])\n    alternateSrc = FindSrcReplacement(fname)\n    if (!is.null(alternateSrc))\n    {\n      s = alternateSrc\n      names(s) = 'src'\n      newNode = xmlNode(\"script\",attrs = s)\n      replaceNodes(node, newNode)\n    }else{\n      str=ReadFileForEmbedding(fname);\n      if (!is.null(str))\n      {      \n        newNode = xmlNode(\"script\", str, attrs = c(type = \"text/javascript\"))\n        replaceNodes(node, newNode)\n      }\n    }\n  }\n  \n  # extract all <link> tags with src value\n  linkNode=getNodeSet(top, '//link[@href]')\n  for (node in linkNode)\n  {\n    b = xmlAttrs(node)\n    fname = file.path(dir, b['href'])\n    str = ReadFileForEmbedding(fname, FALSE);\n    if (!is.null(str))\n    {\n      newNode = xmlNode(\"style\", str)\n      replaceNodes(node, newNode)\n    }\n  }\n  \n  saveXML(html, file = fnameOut)\n  return(TRUE)\n}\n\nReadFileForEmbedding <- function(fname, addCdata = TRUE)\n{\n  data = ReadFullFile(fname)\n  if (is.null(data))\n    return(NULL)\n\n  str = paste(data, collapse ='\\n')\n  if (addCdata) {\n    str = paste(cbind('// <![CDATA[', str,'// ]]>'), collapse ='\\n')\n  }\n  return(str)\n}\n\nReadFullFile <- function(fname)\n{\n  if(!file.exists(fname))\n    return(NULL)\n  \n  con = file(fname, open = \"r\")\n  data = readLines(con)\n  close(con)\n  return(data)\n}\n\nFindSrcReplacement <- function(str)\n{\n  # finds reference to 'plotly' js and replaces with a version from CDN\n  # This allows the HTML to be smaller, since this script is not fully embedded in it\n  str <- iconv(str, to=\"UTF-8\")\n  pattern = \"plotlyjs-(\\\\w.+)/plotly-latest.min.js\"\n  match1=regexpr(pattern, str)\n  attr(match1, 'useBytes') <- FALSE\n  strMatch=regmatches(str, match1, invert = FALSE)\n  if (length(strMatch) == 0) return(NULL)\n  \n  pattern2 = \"-(\\\\d.+)/\"\n  match2 = regexpr(pattern2, strMatch[1])\n  attr(match2, 'useBytes') <- FALSE\n  strmatch = regmatches(strMatch[1], match2)\n  if (length(strmatch) == 0) return(NULL)\n  \n  # CDN url is https://cdn.plot.ly/plotly-<Version>.js\n  # This matches the specific version used in the plotly package used.\n  verstr = substr(strmatch, 2, nchar(strmatch)-1)\n  str = paste('https://cdn.plot.ly/plotly-', verstr,'.min.js', sep='')\n  return(str)\n}\n#################################################\n\n# graphics libraries\nlibraryRequireInstall(\"ggplot2\")\n\nlibraryRequireInstall(\"plotly\")\n\n#clustering libraries\nlibraryRequireInstall(\"dbscan\")\n\n\n############################################\n\n#optics clustering\nversion <- packageVersion(\"dbscan\")\n\n#Remove screenshot feature\ndisabledButtonsList <- list('toImage', 'sendDataToCloud')\nautoSteepnessValue <- c(0.005, 0.05, 0.1, 0.2, 0.5, 0.8, 0.9)\n\nReadFullFileReplaceString <- function(fnameIn, fnameOut, sourceString,targetString)\n{\n  if(!file.exists(fnameIn))\n    return(NULL)\n \n  tx  <- readLines(fnameIn)\n  tx2  <- gsub(pattern = sourceString, replace = targetString, x = tx)\n  writeLines(tx2, con = fnameOut)\n}\n\ngenerateError <- function (errorMsg)\n{\n  xAesthetics <- list(\n    title = sprintf(\n      \"Could not get any cluster assigned as per the values and parameters.\"\n    ),\n    zeroline = FALSE,\n    showline = FALSE,\n    showticklabels = FALSE,\n    showgrid = FALSE\n  )\n  yAesthetics <- list(\n    title = \"\",\n    zeroline = FALSE,\n    showline = FALSE,\n    showticklabels = FALSE,\n    showgrid = FALSE\n  )\n  p <- plot_ly() %>%\n    layout(title = '',\n           xaxis = xAesthetics,\n           yaxis = yAesthetics)\n  \n  p$x$config$modeBarButtonsToRemove = disabledButtonsList\n  internalSaveWidget(p, 'out.html')\n  ReadFullFileReplaceString('out.html', 'out.html', ',\"padding\":40,', ',\"padding\":0,')\n  \n  quit()\n}\n\ntryCatch({\n  ##################################################\n  xdataFrame <- data.frame(Value1)\n  ydataFrame <- data.frame(Value2)\n  ##################################################\n  nColumnsY <- NCOL(ydataFrame)\n  nColumnsX <- NCOL(xdataFrame)\n  nRowsY <- NROW(ydataFrame)\n  nRowsX <- NROW(xdataFrame)\n  \n  ynumericCheck <- sapply(ydataFrame, is.numeric)\n  xnumericCheck <- sapply(xdataFrame, is.numeric)\n\n  parameterSettings <- 'Auto'\n  if (exists(\"clusterSettings_parameterSettings\") )\n  {\n    parameterSettings <- clusterSettings_parameterSettings\n  }\n\n  epsilon <- 1\n  if (exists(\"clusterSettings_epsilon\") &&\n      clusterSettings_epsilon >= 1)\n  {\n    epsilon <- clusterSettings_epsilon\n  }\n\n  minptsClust <- 10\n  if (exists(\"clusterSettings_minptsClust\") &&\n      clusterSettings_minptsClust > 1)\n  {\n    minptsClust <- clusterSettings_minptsClust\n  }\n\n  steepThres<-0.005\n  if (exists(\"clusterSettings_steepThres\") &&\n      clusterSettings_steepThres > 0 && clusterSettings_steepThres < 1)\n  {\n    steepThres <- clusterSettings_steepThres\n  }\n  \n  steepThres <- as.numeric(steepThres)\n  ####################################################\n  plotColor <- \"#FFFFFF\"\n  if (exists(\"plotSettings_plotColor\"))\n  {\n    plotColor <- plotSettings_plotColor\n  }\n  ###############################\n  ### x axis settings######\n  \n  xTitle <- names(xdataFrame)[1]\n  if (exists(\"xaxisSettings_xTitle\") && xaxisSettings_xTitle != '')\n  {\n    xTitle <- xaxisSettings_xTitle\n  }\n  \n  if (nColumnsX > 1) {\n    xTitle <- paste(xTitle, \"(PCA 1)\", sep = \" \")\n  }\n  \n  xZeroline <- TRUE\n  if (exists(\"xaxisSettings_xZeroline\"))\n  {\n    xZeroline <- xaxisSettings_xZeroline\n  }\n  \n  xLabels <- TRUE\n  if (exists(\"xaxisSettings_xLabels\"))\n  {\n    xLabels <- xaxisSettings_xLabels\n  }\n  \n  xGrid <- TRUE\n  if (exists(\"xaxisSettings_xGrid\"))\n  {\n    xGrid <- xaxisSettings_xGrid\n  }\n  \n  xGridCol <- \"#BFC4C5\"\n  if (exists(\"xaxisSettings_xGridCol\"))\n  {\n    xGridCol <- xaxisSettings_xGridCol\n  }\n  \n  xGridWidth <- 0.1\n  if (exists(\"xaxisSettings_xGridWidth\") &&\n      xaxisSettings_xGridWidth <= 5 && xaxisSettings_xGridWidth >= 0.1)\n  {\n    xGridWidth <- xaxisSettings_xGridWidth\n  }\n  \n  xAxisBaseLine <- TRUE\n  if (exists(\"xaxisSettings_xAxisBaseLine\"))\n  {\n    xAxisBaseLine <- xaxisSettings_xAxisBaseLine\n  }\n  \n  xAxisBaseLineCol <- \"#000000\"\n  if (exists(\"xaxisSettings_xAxisBaseLineCol\"))\n  {\n    xAxisBaseLineCol <- xaxisSettings_xAxisBaseLineCol\n  }\n  \n  xAxisBaseLineWidth <- 4\n  if (exists(\"xaxisSettings_xAxisBaseLineWidth\") &&\n      xaxisSettings_xAxisBaseLineWidth <= 11 &&\n      xaxisSettings_xAxisBaseLineWidth >= 1)\n  {\n    xAxisBaseLineWidth <- xaxisSettings_xAxisBaseLineWidth\n  }\n  \n  ##############################\n  ####y axis settings ########\n  \n  yTitle <- names(ydataFrame)[1]\n  if (exists(\"yaxisSettings_yTitle\") && yaxisSettings_yTitle != '')\n  {\n    yTitle <- yaxisSettings_yTitle\n  }\n  if (nColumnsY > 1) {\n    yTitle <- paste(yTitle, \"(PCA 1)\", sep = \" \")\n  }\n  \n  yZeroline <- TRUE\n  if (exists(\"yaxisSettings_yZeroline\"))\n  {\n    yZeroline <- yaxisSettings_yZeroline\n  }\n  \n  yLabels <- TRUE\n  if (exists(\"yaxisSettings_yLabels\"))\n  {\n    yLabels <- yaxisSettings_yLabels\n  }\n  \n  yGrid <- TRUE\n  if (exists(\"yaxisSettings_yGrid\"))\n  {\n    yGrid <- yaxisSettings_yGrid\n  }\n  \n  yGridCol <- \"#BFC4C5\"\n  if (exists(\"yaxisSettings_yGridCol\"))\n  {\n    yGridCol <- yaxisSettings_yGridCol\n  }\n  \n  yGridWidth <- 0.1\n  if (exists(\"yaxisSettings_yGridWidth\") &&\n      yaxisSettings_yGridWidth <= 5 && yaxisSettings_yGridWidth >= 0.1)\n  {\n    yGridWidth <- yaxisSettings_yGridWidth\n  }\n  \n  yAxisBaseLine <- TRUE\n  if (exists(\"yaxisSettings_yAxisBaseLine\"))\n  {\n    yAxisBaseLine <- yaxisSettings_yAxisBaseLine\n  }\n  \n  yAxisBaseLineCol <- \"#000000\"\n  if (exists(\"yaxisSettings_yAxisBaseLineCol\"))\n  {\n    yAxisBaseLineCol <- yaxisSettings_yAxisBaseLineCol\n  }\n  \n  yAxisBaseLineWidth <- 4\n  if (exists(\"yaxisSettings_yAxisBaseLineWidth\") &&\n      yaxisSettings_yAxisBaseLineWidth <= 11 &&\n      yaxisSettings_yAxisBaseLineWidth >= 1)\n  {\n    yAxisBaseLineWidth <- yaxisSettings_yAxisBaseLineWidth\n  }\n  ############################################################\n  ############################################################\n  ###################plot setting lists#############\n  \n  xAesthetics <- list(\n    title = xTitle,\n    zeroline = xZeroline,\n    showticklabels = xLabels,\n    showgrid = xGrid,\n    gridcolor = toRGB(xGridCol),\n    gridwidth = xGridWidth,\n    showline = xAxisBaseLine,\n    linecolor = toRGB(xAxisBaseLineCol),\n    linewidth = xAxisBaseLineWidth\n  )\n  yAesthetics <- list(\n    title = yTitle,\n    zeroline = yZeroline,\n    showticklabels = yLabels,\n    showgrid = yGrid,\n    gridcolor = toRGB(yGridCol),\n    gridwidth = yGridWidth,\n    showline = yAxisBaseLine,\n    linecolor = toRGB(yAxisBaseLineCol),\n    linewidth = yAxisBaseLineWidth\n  )\n  \n  \n  ############################################################\n  ############################################################\n  ############################################################\n  ###################methods to handle missing values and tooltips#########\n  \n  getmode <- function(v) {\n    uniqv <- unique(v)\n    uniqv[which.max(tabulate(match(v, uniqv)))]\n  }\n  \n  getTooltips <- function() {\n    xInfo1 <- Value1[1]\n    yInfo1 <- Value2[1]\n    colnames(xInfo1) <- c(\"X\")\n    colnames(yInfo1) <- c(\"Y\")\n    xInfo1 <- data.frame(xInfo1)\n    yInfo1 <- data.frame(yInfo1)\n    if (exists(\"Tooltip\"))\n    {\n      tooltip1 <- Tooltip\n      x <- cbind(\n        x = finalXvector,\n        y = finalYvector,\n        tooltip = tooltip1,\n        xInfo = xInfo1,\n        yInfo = yInfo1\n      )\n    }\n    else{\n      x <- cbind(\n        x = finalXvector,\n        y = finalYvector,\n        xInfo = xInfo1,\n        yInfo = yInfo1\n      )\n    }\n    \n    return (x)\n  }\n  \n  dataScaling <- function (dataFrame)\n  {\n    nMin <- -3\n    nMax <- 3\n    min <- min(dataFrame)\n    max <- max(dataFrame)\n    nX = nMin + (nMax - nMin) * (dataFrame - min) / (max - min)\n    return(nX)\n  }\n  \n  ###############################################################\n  #handle missing values and generalize different formats of data\n  \n  for (iCounter in 1:nColumnsY)\n  {\n    if (ynumericCheck[iCounter] == FALSE)\n    {\n      modeValue <- getmode(ydataFrame[, iCounter])\n      for (jCounter in 1:nRowsY)\n      {\n        if (is.na(ydataFrame[jCounter, iCounter]))\n        {\n          ydataFrame[jCounter, iCounter] <- modeValue\n        }\n      }\n      uniqueLevels <- levels(ydataFrame[, iCounter])\n      levels(ydataFrame[, iCounter]) <- 1:NROW(uniqueLevels)\n      ydataFrame[, iCounter] <-\n        as.numeric(as.character(ydataFrame[, iCounter]))\n    }\n    \n    if (ynumericCheck[iCounter] == TRUE)\n    {\n      meanValue <- mean(ydataFrame[, iCounter], trim = 0 , na.rm = TRUE)\n      for (jCounter in 1:nRowsY)\n      {\n        if (is.na(ydataFrame[jCounter, iCounter]))\n        {\n          ydataFrame[jCounter, iCounter] <- meanValue\n        }\n      }\n    }\n  }\n  \n  \n  for (iCounter in 1:nColumnsX)\n  {\n    if (xnumericCheck[iCounter] == FALSE)\n    {\n      xModeValue <- getmode(xdataFrame[, iCounter])\n      for (jCounter in 1:nRowsX)\n      {\n        if (is.na(xdataFrame[jCounter, iCounter]))\n        {\n          xdataFrame[jCounter, iCounter] <- xModeValue\n        }\n      }\n      uniqueLevels <- levels(xdataFrame[, iCounter])\n      levels(xdataFrame[, iCounter]) <- 1:NROW(uniqueLevels)\n      xdataFrame[, iCounter] <-\n        as.numeric(as.character(xdataFrame[, iCounter]))\n    }\n    \n    if (xnumericCheck[iCounter] == TRUE)\n    {\n      xMeanValue <- mean(xdataFrame[, iCounter], trim = 0 , na.rm = TRUE)\n      for (jCounter in 1:nRowsX)\n      {\n        if (is.na(xdataFrame[jCounter, iCounter]))\n        {\n          xdataFrame[jCounter, iCounter] <- xMeanValue\n        }\n      }\n    }\n  }\n  \n  ############################################################\n  ############################################################\n  ############################################################\n  ###################data Scaling#############################\n  \n  maxYData <- max(ydataFrame)\n  maxXData <- max(xdataFrame)\n  maxXYData <- max(c(maxYData, maxXData))\n  \n  if (exists(\"clusterSettings_scaling\") &&\n      clusterSettings_scaling) {\n    scaledYdata <- ydataFrame\n    \n    scaledXdata <- xdataFrame\n    \n    for (iCounter in 1:nColumnsY) {\n      tempF <- dataScaling(scaledYdata[, iCounter])\n      scaledYdata[, iCounter] <- tempF\n    }\n    for (iCounter in 1:nColumnsX) {\n      tempF <- dataScaling(scaledXdata[, iCounter])\n      scaledXdata[, iCounter] <- tempF\n    }\n  } else {\n    epsilon <- epsilon * ((maxXYData * 5) / 100)\n    scaledYdata <- ydataFrame\n    scaledXdata <- xdataFrame\n  }\n  \n  scaledYdata <- data.frame(scaledYdata)\n  scaledXdata <- data.frame(scaledXdata)\n  \n  ############################################################\n  ############################################################\n  ############################################################\n  ###PCA for dimensions both axis in case dimensions are >2###\n  \n  if (NCOL(scaledYdata) > 1)\n  {\n    yVectorPCA <- prcomp(t(scaledYdata))\n    yVectorPCA <- yVectorPCA$rotation\n    yVectorPCA <- data.frame(yVectorPCA)\n    yVectorPCA <- yVectorPCA[1]\n  }\n  if (NCOL(scaledXdata) > 1)\n  {\n    xVectorPCA <- prcomp(t(scaledXdata))\n    xVectorPCA <- xVectorPCA$rotation\n    xVectorPCA <- data.frame(xVectorPCA)\n    xVectorPCA <- xVectorPCA[1]\n  }\n  \n  ############################################################\n  ############################################################\n  ############################################################\n  #################data binding###############################\n  if (NCOL(scaledYdata) > 1)\n  {\n    finalYvector <- yVectorPCA\n  }\n  if (NCOL(scaledXdata) > 1)\n  {\n    finalXvector <- xVectorPCA\n  }\n  if (NCOL(scaledYdata) == 1)\n  {\n    finalYvector <- scaledYdata\n  }\n  if (NCOL(scaledXdata) == 1)\n  {\n    finalXvector <- scaledXdata\n  }\n  \n  colnames(finalYvector) <- c(\"y\")\n  colnames(finalXvector) <- c(\"x\")\n  \n  #Data binding\n  x <- cbind(x = finalXvector,\n             y = finalYvector)\n  \n  ############################################################\n  ############################################################\n  ############################################################\n  #########clustering and plotting implementations############\n  \n  # generating color palette for clusters by using Power BI Colors\n  colPalette <-\n    c(\n      \"#DFBFDF\",\n      \"#3599B8\",\n      \"#A66999\",\n      \"#FE9666\",\n      \"#8AD4EB\",\n      \"#F2C80F\",\n      \"#FD625E\",\n      \"#01B8AA\"\n    )\n  \n  getOpticsXi_new <- function (x, epsilon) {\n    points = nrow(x)\n    while (epsilon < maxXYData) {\n      for (value in autoSteepnessValue) {\n        while (points > 1) {\n          isPassed <- TRUE\n          if (isPassed) {\n            tryCatch({\n              res <- optics(x, eps = epsilon, minPts = points)\n              print(res)\n              res <- opticsXi(res, xi = value)\n              print(res)\n              isPassed <- FALSE\n              return (res)\n            }, error = function(e) {\n              isPassed <- TRUE\n            }, warning = function(w) {\n              isPassed <- TRUE\n            })\n          }\n          points <- round(points / 2)\n        }\n      }\n      epsilon <- epsilon * 2\n      points = nrow(x)\n    }\n  }\n  \n  getExtractXi_new <- function (x, epsilon) {\n    points = nrow(x)\n    while (epsilon < maxXYData) {\n      for (value in autoSteepnessValue) {\n        while (points > 1) {\n          isPassed <- TRUE\n          if (isPassed) {\n            tryCatch({\n              res <- optics(x, eps = epsilon, minPts = points)\n              print(res)\n              res <- extractXi(res, xi = value)\n              print(res)\n              isPassed <- FALSE\n              return (res)\n            }, error = function(e) {\n              isPassed <- TRUE\n            }, warning = function(w) {\n              isPassed <- TRUE\n            })\n          }\n          points <- round(points / 2)\n        }\n      }\n      epsilon <- epsilon * 2\n      points = nrow(x)\n    }\n  }\n  \n  epsilonMultiplier <- maxXYData / 10\n  autoEpsilon <- c(epsilonMultiplier)\n  for (iCounter in 2:10) {\n    autoEpsilon <- append(autoEpsilon, epsilonMultiplier * iCounter)\n  }\n  \n  ############################################################\n  if (version < 1) {\n    # handling for older libraries (used in Power BI app sevice)\n    if (parameterSettings == 'Manual') {\n      res <- optics(x, eps = epsilon, minPts = minptsClust)\n      res <- opticsXi(res, xi = steepThres)\n    } else {\n      res <- getOpticsXi_new(x, epsilon)\n    }\n    \n    \n    ############################################################\n  }\n  else{\n    # handling for newer libraries (Power BI desktop)\n    if (parameterSettings == 'Manual') {\n      res <- optics(x, eps = epsilon, minPts = minptsClust)\n      res <- extractXi(res, xi = steepThres)\n    } else {\n      res <- getExtractXi_new(x, epsilon)\n    }\n  }\n  \n  ########## Function for hull plot ############\n  cl <- res\n  col <- colPalette\n  cex = 0.5\n  hull_lwd = 1\n  hull_lty = 1\n  solid = TRUE\n  alpha = .2\n  main = \"OPTICS\"\n  \n  ### extract clustering (keep hierarchical xICSXi structure)\n  if (is(cl, \"xics\") || \"clusters_xi\" %in% names(cl)) {\n    clusters_xi <- cl$clusters_xi\n    cl_order <- cl$order\n  } else\n    clusters_xi <- NULL\n  \n  if (is.list(cl))\n    cl <- cl$cluster\n  if (!is.numeric(cl))\n    stop(\"Could not get any cluster assigned as per the values and parameters entered.\")\n  \n  if (is.null(col))\n    col <- palette()\n  if (max(cl) + 1L > length(col))\n    warning(\"Not enough colors to display clusters. Some colors may get reused.\")\n  \n  if (is.null(hull_lwd) || is.na(hull_lwd) || hull_lwd == 0) {\n    hull_lwd <- 1\n    border <- NA\n  }\n  \n  if (is(cl, \"xics\") || \"clusters_xi\" %in% names(cl)) {\n    ## this is necessary for larger datasets: Ensure largest is plotted first\n    clusters_xi <-\n      clusters_xi[order(-(clusters_xi$end - clusters_xi$start)), ] # Order by size (descending)\n    ci_order <- clusters_xi$cluster_id\n  } else {\n    ci_order <- 1:max(cl)\n  }\n  \n  pointCol <- col[cl %% length(col) + 1L]\n  p <- ggplot()\n  \n  col_poly <- adjustcolor(col)\n  border <- col\n  \n  for (i in 1:length(ci_order)) {\n    ### use all the points for xICSXi's hierarchical structure\n    if (is.null(clusters_xi)) {\n      d <- x[cl == i, ]\n    }\n    else {\n      d <- x[cl_order[clusters_xi$start[i]:clusters_xi$end[i]], ]\n    }\n    \n    ch <- chull(d)\n    ch <- c(ch, ch[1])\n    \n    polyCol <- col_poly[ci_order[i] %% length(col_poly) + 1L]\n    borderCol <- border[ci_order[i] %% length(col_poly) + 1L]\n    \n    \n    p <-\n      p + geom_polygon(\n        data = d[ch, ],\n        aes(x = x, y = y),\n        fill = polyCol,\n        colour = borderCol,\n        alpha = 0.2\n      )\n    \n  }\n  x <- getTooltips()\n  if (exists(\"Tooltip\")) {\n    p <-\n      p + geom_point(\n        data = x,\n        aes(\n          x = x,\n          y = y,\n          xTooltip = X,\n          yTooltip = Y,\n          userTooltip = Tooltip\n        ),\n        colour = pointCol\n      )\n    p <-\n      ggplotly(p, tooltip = c('xTooltip', 'yTooltip', 'userTooltip')) %>%\n      layout(\n        title = '',\n        xaxis = xAesthetics,\n        yaxis = yAesthetics,\n        margin = list(\n          l = 50,\n          r = 0,\n          t = 50,\n          b = 50\n        ),\n        plot_bgcolor = plotColor\n      )\n  }\n  else{\n    p <-\n      p + geom_point(data = x,\n                     aes(\n                       x = x,\n                       y = y,\n                       xTooltip = X,\n                       yTooltip = Y\n                     ),\n                     colour = pointCol)\n    p <- ggplotly(p, tooltip = c('xTooltip', 'yTooltip')) %>%\n      layout(\n        title = '',\n        xaxis = xAesthetics,\n        yaxis = yAesthetics,\n        margin = list(\n          l = 50,\n          r = 0,\n          t = 50,\n          b = 50\n        ),\n        plot_bgcolor = plotColor\n      )\n  }\n  p$x$config$modeBarButtonsToRemove = disabledButtonsList\n  #printing the plot on visual device\n  internalSaveWidget(config(p, collaborate = FALSE, displaylogo = FALSE), 'out.html')\n  ReadFullFileReplaceString('out.html', 'out.html', ',\"padding\":40,', ',\"padding\":0,')\n  \n  quit()\n},\nerror = function(e)\n{\n  #catching error and displaying message\n  generateError (e)\n})"
          }
        }
      }
    ],
    "objects": {
      "rcv_script": {
        "properties": {
          "provider": {
            "type": {
              "text": true
            }
          },
          "source": {
            "type": {
              "scripting": {
                "source": true
              }
            }
          }
        }
      },
      "clusterSettings": {
        "displayName": "Clustering settings",
        "description": "Settings to control clusters",
        "properties": {
          "parameterSettings": {
            "displayName": "Parameter setting",
            "description": "Set the parameters for the Clustering using OPTICS",
            "type": {
              "enumeration": [
                {
                  "displayName": "Auto",
                  "value": "Auto"
                },
                {
                  "displayName": "User defined",
                  "value": "Manual"
                }
              ]
            }
          },
          "scaling": {
            "displayName": "Data scaling",
            "description": "Enable data scaling",
            "type": {
              "bool": true
            }
          },
          "epsilon": {
            "displayName": "Epsilon neighbours",
            "description": "It is the upper limit of the size of the epsilon neighborhood. Limiting the neighborhood size improves performance and has no or very little impact on the ordering as long as it is not set too low",
            "placeHolderText": "Auto",
            "type": {
              "numeric": true
            }
          },
          "minptsClust": {
            "displayName": "Min number of points in a cluster",
            "description": "Number of minimum points in the threshold region. The parameter is used to identify dense neighborhoods and the reachability distance is calculated as the distance to the minPts nearest neighbor",
            "placeHolderText": "Auto",
            "type": {
              "numeric": true
            }
          },
          "steepThres": {
            "displayName": "Steepness threshold",
            "description": "Between 0 to 1. Steepness threshold to identify clusters hierarchically using the Xi method",
            "placeHolderText": "Auto",
            "type": {
              "numeric": true
            }
          }
        }
      },
      "plotSettings": {
        "displayName": "Plot settings",
        "description": "Settings plot appereance",
        "properties": {
          "title": {
            "displayName": "Title",
            "description": "Title",
            "type": {
              "text": true
            }
          },
          "plotColor": {
            "displayName": "Plot background color",
            "description": "Plot background color",
            "type": {
              "fill": {
                "solid": {
                  "color": true
                }
              }
            }
          }
        }
      },
      "xaxisSettings": {
        "displayName": "X-Axis",
        "description": "Appereance settings for X-Axis",
        "properties": {
          "xTitle": {
            "displayName": "Title",
            "description": "Title",
            "placeHolderText": "Auto",
            "type": {
              "text": true
            }
          },
          "xZeroline": {
            "displayName": "Zeroline",
            "description": "Zeroline",
            "type": {
              "bool": true
            }
          },
          "xLabels": {
            "displayName": "Labels",
            "description": "Labels",
            "type": {
              "bool": true
            }
          },
          "xGrid": {
            "displayName": "Gridlines",
            "description": "Gridlines",
            "type": {
              "bool": true
            }
          },
          "xGridCol": {
            "displayName": "Gridlines color",
            "description": "Color of gridlines",
            "type": {
              "fill": {
                "solid": {
                  "color": true
                }
              }
            }
          },
          "xGridWidth": {
            "displayName": "Gridlines width",
            "description": "Width of gridlines",
            "type": {
              "numeric": true
            }
          },
          "xAxisBaseLine": {
            "displayName": "Baseline",
            "description": "Baseline",
            "type": {
              "bool": true
            }
          },
          "xAxisBaseLineCol": {
            "displayName": "Baseline color",
            "description": "Color of baseline",
            "type": {
              "fill": {
                "solid": {
                  "color": true
                }
              }
            }
          },
          "xAxisBaseLineWidth": {
            "displayName": "Baseline width",
            "description": "Width of baseline",
            "type": {
              "numeric": true
            }
          }
        }
      },
      "yaxisSettings": {
        "displayName": "Y-Axis",
        "description": "Appereance settings for Y-Axis",
        "properties": {
          "yTitle": {
            "displayName": "Title",
            "description": "Title",
            "placeHolderText": "Auto",
            "type": {
              "text": true
            }
          },
          "yZeroline": {
            "displayName": "Zeroline",
            "description": "Zeroline",
            "type": {
              "bool": true
            }
          },
          "yLabels": {
            "displayName": "Labels",
            "description": "Labels",
            "type": {
              "bool": true
            }
          },
          "yGrid": {
            "displayName": "Gridlines",
            "description": "Gridlines",
            "type": {
              "bool": true
            }
          },
          "yGridCol": {
            "displayName": "Gridlines color",
            "description": "Color of gridlines",
            "type": {
              "fill": {
                "solid": {
                  "color": true
                }
              }
            }
          },
          "yGridWidth": {
            "displayName": "Gridlines width",
            "description": "Width of gridlines",
            "type": {
              "numeric": true
            }
          },
          "yAxisBaseLine": {
            "displayName": "Baseline",
            "description": "Baseline",
            "type": {
              "bool": true
            }
          },
          "yAxisBaseLineCol": {
            "displayName": "Baseline color",
            "description": "Color of baseline",
            "type": {
              "fill": {
                "solid": {
                  "color": true
                }
              }
            }
          },
          "yAxisBaseLineWidth": {
            "displayName": "Baseline width",
            "description": "Width of baseline",
            "type": {
              "numeric": true
            }
          }
        }
      }
    },
    "suppressDefaultTitle": true
  },
  "dependencies": {
    "cranPackages": [
      {
        "name": "ggplot2",
        "displayName": "GG Plot 2",
        "url": "https://cran.r-project.org/web/packages/ggplot2/index.html"
      },
      {
        "name": "plotly",
        "displayName": "Plotly",
        "url": "https://cran.r-project.org/web/packages/plotly/index.html"
      },
      {
        "name": "htmlwidgets",
        "displayName": "HTML Widgets",
        "url": "https://cran.r-project.org/web/packages/htmlwidgets/index.html"
      },
      {
        "name": "XML",
        "displayName": "XML",
        "url": "https://cran.r-project.org/web/packages/XML/index.html"
      },
      {
        "name": "forecast",
        "displayName": "forecast",
        "url": "https://cran.r-project.org/web/packages/forecast/index.html"
      },
      {
        "name": "dbscan",
        "displayName": "dbscan",
        "url": "https://cran.r-project.org/web/packages/dbscan/index.html"
      }
    ]
  },
  "stringResources": {},
  "content": {
    "js": "var powerbi;!function(e){var t;!function(e){var t;!function(e){var t;!function(e){var t;!function(e){function t(e,t,n){void 0===e&&(e=[]);var s=e;return i(s),t&&(s.identityFields=t),n&&(s.source=n),s}function i(e,t){e.grouped=t?function(){return t}:function(){return n(e)}}function n(e){for(var t,i=[],n=0,s=e.length;s>n;n++){var r=e[n];if(!t||t.identity!==r.identity){if(t={values:[]},r.identity){t.identity=r.identity;var a=r.source;void 0!==a.groupName?t.name=a.groupName:a.displayName&&(t.name=a.displayName)}i.push(t)}t.values.push(r)}return i}e.createValueColumns=t,e.setGrouped=i,e.groupValues=n}(t=e.DataViewTransform||(e.DataViewTransform={}))}(t=e.dataview||(e.dataview={}))}(t=e.utils||(e.utils={}))}(t=e.extensibility||(e.extensibility={}))}(powerbi||(powerbi={}));var powerbi;!function(e){var t;!function(e){var t;!function(e){var t;!function(e){var t;!function(e){function t(e,t){if(!e||!e.length)return-1;var i=e[0];if(i.values&&i.values.length>0)for(var s=0,r=i.values.length;r>s;++s){var a=i.values[s];if(a&&a.source&&n(a.source,t))return s}return-1}function i(e,t){if(e&&e.length)for(var i=0,s=e.length;s>i;i++)if(n(e[i].source,t))return i;return-1}function n(e,t){var i=e.roles;return i&&i[t]}function s(e,t){return null!=e&&null!=e.metadata&&e.metadata.columns&&e.metadata.columns.some(function(e){return e.roles&&void 0!==e.roles[t]})}function r(e,t){return e&&e.source&&e.source.roles&&e.source.roles[t]===!0}e.getMeasureIndexOfRole=t,e.getCategoryIndexOfRole=i,e.hasRole=n,e.hasRoleInDataView=s,e.hasRoleInValueColumn=r}(t=e.DataRoleHelper||(e.DataRoleHelper={}))}(t=e.dataview||(e.dataview={}))}(t=e.utils||(e.utils={}))}(t=e.extensibility||(e.extensibility={}))}(powerbi||(powerbi={}));var powerbi;!function(e){var t;!function(e){var t;!function(e){var t;!function(e){var t;!function(e){function t(e,t,i){if(!e)return i;var n=e[t];return void 0===n?i:n}function i(e,i,n){var s=t(e,i);return s&&s.solid?s.solid.color:n}e.getValue=t,e.getFillColorByPropertyName=i}(t=e.DataViewObject||(e.DataViewObject={}))}(t=e.dataview||(e.dataview={}))}(t=e.utils||(e.utils={}))}(t=e.extensibility||(e.extensibility={}))}(powerbi||(powerbi={}));var powerbi;!function(e){var t;!function(e){var t;!function(e){var t;!function(e){var t;!function(t){function i(t,i,n){return t?e.DataViewObject.getValue(t[i.objectName],i.propertyName,n):n}function n(e,t,i){return e&&e[t]?e[t]:i}function s(e,t,n){var s=i(e,t);return s&&s.solid?s.solid.color:n}function r(e,t,n){var s=i(e,t,n);return s&&s.solid?s.solid.color:void 0===s||null===s||\"object\"==typeof s&&!s.solid?n:s}t.getValue=i,t.getObject=n,t.getFillColor=s,t.getCommonValue=r}(t=e.DataViewObjects||(e.DataViewObjects={}))}(t=e.dataview||(e.dataview={}))}(t=e.utils||(e.utils={}))}(t=e.extensibility||(e.extensibility={}))}(powerbi||(powerbi={}));var powerbi;!function(e){var t;!function(t){var i;!function(t){var i;!function(t){var i,n=e.extensibility.utils.dataview.DataRoleHelper;!function(e){function t(e,t,i){if(e.categories&&e.categories.length>0){var s=e.categories[0];return s.source&&n.hasRole(s.source,t)&&n.hasRole(s.source,i)}return!1}function i(e){return void 0!==e.groupName?e.groupName:e.queryName}function s(e){var t=a(e);return null!=t&&t.imageUrl===!0}function r(e){var t=a(e);return null!=t&&t.webUrl===!0}function a(e){return e&&e.type&&e.type.misc}function o(e){return e&&e.metadata&&e.metadata.columns&&e.metadata.columns.length?e.metadata.columns.some(function(e){return s(e)===!0}):!1}e.categoryIsAlsoSeriesRole=t,e.getSeriesName=i,e.isImageUrlColumn=s,e.isWebUrlColumn=r,e.getMiscellaneousTypeDescriptor=a,e.hasImageUrlColumn=o}(i=t.converterHelper||(t.converterHelper={}))}(i=t.dataview||(t.dataview={}))}(i=t.utils||(t.utils={}))}(t=e.extensibility||(e.extensibility={}))}(powerbi||(powerbi={}));var powerbi;!function(e){var t;!function(e){var t;!function(e){var t;!function(e){var t=function(){function t(){}return t.getDefault=function(){return new this},t.createPropertyIdentifier=function(e,t){return{objectName:e,propertyName:t}},t.parse=function(t){var i,n=this.getDefault();if(!t||!t.metadata||!t.metadata.objects)return n;i=n.getProperties();for(var s in i)for(var r in i[s]){var a=n[s][r];n[s][r]=e.DataViewObjects.getCommonValue(t.metadata.objects,i[s][r],a)}return n},t.isPropertyEnumerable=function(e){return!t.InnumerablePropertyPrefix.test(e)},t.enumerateObjectInstances=function(e,t){var i=e&&e[t.objectName];if(!i)return[];var n={objectName:t.objectName,selector:null,properties:{}};for(var s in i)i.hasOwnProperty(s)&&(n.properties[s]=i[s]);return{instances:[n]}},t.prototype.getProperties=function(){var e=this,i={},n=Object.keys(this);return n.forEach(function(n){if(t.isPropertyEnumerable(n)){var s=Object.keys(e[n]);i[n]={},s.forEach(function(e){t.isPropertyEnumerable(n)&&(i[n][e]=t.createPropertyIdentifier(n,e))})}}),i},t}();t.InnumerablePropertyPrefix=/^_/,e.DataViewObjectsParser=t}(t=e.dataview||(e.dataview={}))}(t=e.utils||(e.utils={}))}(t=e.extensibility||(e.extensibility={}))}(powerbi||(powerbi={}));var powerbi;!function(e){var t;!function(e){var t;!function(e){var t;!function(e){\"use strict\";function t(){a=0}function i(){return 0===a}function n(e,t){var i=[];if(e&&e.hasChildNodes()){for(var n=e.children,r=0;r<n.length;r++){var a=void 0;a=\"script\"===n.item(r).nodeName.toLowerCase()?s(n.item(r)):n.item(r).cloneNode(!0),t.appendChild(a),i.push(a)}return i}}function s(e){for(var t=document.createElement(\"script\"),i=e.attributes,n=0;n<i.length;n++)t.setAttribute(i[n].name,i[n].textContent),\"src\"===i[n].name.toLowerCase()&&(a++,t.onload=function(){a--});return t.innerHTML=e.innerHTML,t}function r(){var e=window.setInterval(function(){i()&&(window.clearInterval(e),window.hasOwnProperty(\"HTMLWidgets\")&&window.HTMLWidgets.staticRender&&window.HTMLWidgets.staticRender())},100)}var a=0;e.ResetInjector=t,e.injectorReady=i,e.ParseElement=n,e.RunHTMLWidgetRenderer=r}(t=e.ClusteringUsingOPTICSCAD9384DAA1042E78771F55A0BD811D8||(e.ClusteringUsingOPTICSCAD9384DAA1042E78771F55A0BD811D8={}))}(t=e.visual||(e.visual={}))}(t=e.extensibility||(e.extensibility={}))}(powerbi||(powerbi={}));var powerbi;!function(e){var t;!function(e){var t;!function(e){var t;!function(e){function t(e,t,i,n){if(e){var s=e[t];if(s){var r=s[i];if(void 0!==r)return r}}return n}function i(e,t,i,n,s){var r=e.objects;if(r){var a=r[t];if(a){var o=a[i];if(o){var l=o[n];if(void 0!==l)return l}}}return s}e.getValue=t,e.getCategoricalObjectValue=i}(t=e.ClusteringUsingOPTICSCAD9384DAA1042E78771F55A0BD811D8||(e.ClusteringUsingOPTICSCAD9384DAA1042E78771F55A0BD811D8={}))}(t=e.visual||(e.visual={}))}(t=e.extensibility||(e.extensibility={}))}(powerbi||(powerbi={}));var powerbi;!function(e){var t;!function(t){var i;!function(t){var i;!function(t){\"use strict\";var i=!1,n=[e.VisualUpdateType.Resize,e.VisualUpdateType.ResizeEnd,e.VisualUpdateType.Resize+e.VisualUpdateType.ResizeEnd],s=function(){function e(e){e&&e.element&&(this.rootElement=e.element),this.headNodes=[],this.bodyNodes=[],this.clusterSettings={parameterSettings:\"Auto\",scaling:!1,epsilon:1,minptsClust:10,steepThres:.08},this.plotSettings={title:\"Clusters\",plotColor:\"#FFFFFF\"},this.xAxisSettings={title:\"X\",zeroline:!0,labels:!0,grid:!0,gridCol:\"#BFC4C5\",gridWidth:.1,axisBaseLine:!0,axisBaseLineCol:\"#000000\",axisBaseLineWidth:4},this.yAxisSettings={title:\"Y\",zeroline:!0,labels:!0,grid:!0,gridCol:\"#BFC4C5\",gridWidth:.1,axisBaseLine:!0,axisBaseLineCol:\"#000000\",axisBaseLineWidth:4}}return e.prototype.update=function(e){if(e&&e.type&&e.viewport&&e.dataViews&&0!==e.dataViews.length&&e.dataViews[0]){var t=e.dataViews[0];this.updateObjects(t.metadata.objects);var i=null;t.scriptResult&&t.scriptResult.payloadBase64&&(i=t.scriptResult.payloadBase64),-1===n.indexOf(e.type)?i&&this.injectCodeFromPayload(i):this.onResizing(e.viewport)}},e.prototype.onResizing=function(e){},e.prototype.injectCodeFromPayload=function(e){if(t.ResetInjector(),e){var n=document.createElement(\"html\");try{n.innerHTML=window.atob(e)}catch(s){return}if(i||0===this.headNodes.length){for(;this.headNodes.length>0;){var r=this.headNodes.pop();document.head.removeChild(r)}var a=n.getElementsByTagName(\"head\");if(a&&a.length>0){var o=a[0];this.headNodes=t.ParseElement(o,document.head)}}for(;this.bodyNodes.length>0;){var r=this.bodyNodes.pop();this.rootElement.removeChild(r)}var l=n.getElementsByTagName(\"body\");if(l&&l.length>0){var u=l[0];this.bodyNodes=t.ParseElement(u,this.rootElement)}t.RunHTMLWidgetRenderer()}},e.prototype.updateObjects=function(e){var i=t.getValue(e,\"clusterSettings\",\"scaling\",!1),n=t.getValue(e,\"clusterSettings\",\"epsilon\",null);null!==n&&(n=1>n?1:n);var s=t.getValue(e,\"clusterSettings\",\"minptsClust\",null),r=t.getValue(e,\"clusterSettings\",\"steepThres\",null),a=t.getValue(e,\"xaxisSettings\",\"xGridWidth\",.1);a=.1>a?.1:a>5?.1:t.getValue(e,\"xaxisSettings\",\"xGridWidth\",.1);var o=t.getValue(e,\"xaxisSettings\",\"xAxisBaseLineWidth\",4);o=1>o?4:o>11?4:t.getValue(e,\"xaxisSettings\",\"xAxisBaseLineWidth\",4);var l=t.getValue(e,\"yaxisSettings\",\"yGridWidth\",.1);l=.1>l?.1:l>5?.1:t.getValue(e,\"yaxisSettings\",\"yGridWidth\",.1);var u=t.getValue(e,\"yaxisSettings\",\"yAxisBaseLineWidth\",4);u=1>u?4:u>11?4:t.getValue(e,\"yaxisSettings\",\"yAxisBaseLineWidth\",4),this.clusterSettings={parameterSettings:t.getValue(e,\"clusterSettings\",\"parameterSettings\",\"Auto\"),scaling:i,epsilon:n,minptsClust:s,steepThres:r},this.plotSettings={title:t.getValue(e,\"plotSettings\",\"title\",\"Clusters\"),plotColor:t.getValue(e,\"plotSettings\",\"plotColor\",\"#FFFFFF\")},this.xAxisSettings={title:t.getValue(e,\"xaxisSettings\",\"xTitle\",\"\"),zeroline:t.getValue(e,\"xaxisSettings\",\"xZeroline\",!0),labels:t.getValue(e,\"xaxisSettings\",\"xLabels\",!0),grid:t.getValue(e,\"xaxisSettings\",\"xGrid\",!0),gridCol:t.getValue(e,\"xaxisSettings\",\"xGridCol\",\"#BFC4C5\"),gridWidth:a,axisBaseLine:t.getValue(e,\"xaxisSettings\",\"xAxisBaseLine\",!0),axisBaseLineCol:t.getValue(e,\"xaxisSettings\",\"xAxisBaseLineCol\",\"#000000\"),axisBaseLineWidth:o},this.yAxisSettings={title:t.getValue(e,\"yaxisSettings\",\"yTitle\",\"\"),zeroline:t.getValue(e,\"yaxisSettings\",\"yZeroline\",!0),labels:t.getValue(e,\"yaxisSettings\",\"yLabels\",!0),grid:t.getValue(e,\"yaxisSettings\",\"yGrid\",!0),gridCol:t.getValue(e,\"yaxisSettings\",\"yGridCol\",\"#BFC4C5\"),gridWidth:l,axisBaseLine:t.getValue(e,\"yaxisSettings\",\"yAxisBaseLine\",!0),axisBaseLineCol:t.getValue(e,\"yaxisSettings\",\"yAxisBaseLineCol\",\"#000000\"),axisBaseLineWidth:u}},e.prototype.enumerateObjectInstances=function(e){var t;t=e.objectName;var i;i=[];var n;switch(t){case\"clusterSettings\":n={},n.parameterSettings=this.clusterSettings.parameterSettings,n.scaling=this.clusterSettings.scaling,\"Auto\"===this.clusterSettings.parameterSettings||(n.epsilon=this.clusterSettings.epsilon,n.minptsClust=this.clusterSettings.minptsClust,n.steepThres=this.clusterSettings.steepThres),i.push({objectName:t,properties:n,selector:null});break;case\"plotSettings\":i.push({objectName:t,properties:{plotColor:this.plotSettings.plotColor},selector:null});break;case\"xaxisSettings\":i.push({objectName:t,properties:{xTitle:this.xAxisSettings.title,xZeroline:this.xAxisSettings.zeroline,xLabels:this.xAxisSettings.labels,xGrid:this.xAxisSettings.grid,xGridCol:this.xAxisSettings.gridCol,xGridWidth:this.xAxisSettings.gridWidth,xAxisBaseLine:this.xAxisSettings.axisBaseLine,xAxisBaseLineCol:this.xAxisSettings.axisBaseLineCol,xAxisBaseLineWidth:this.xAxisSettings.axisBaseLineWidth},selector:null});break;case\"yaxisSettings\":i.push({objectName:t,properties:{yTitle:this.yAxisSettings.title,yZeroline:this.yAxisSettings.zeroline,yLabels:this.yAxisSettings.labels,yGrid:this.yAxisSettings.grid,yGridCol:this.yAxisSettings.gridCol,yGridWidth:this.yAxisSettings.gridWidth,yAxisBaseLine:this.yAxisSettings.axisBaseLine,yAxisBaseLineCol:this.yAxisSettings.axisBaseLineCol,yAxisBaseLineWidth:this.yAxisSettings.axisBaseLineWidth},selector:null})}return i},e}();t.ClusteringUsingOPTICS=s}(i=t.ClusteringUsingOPTICSCAD9384DAA1042E78771F55A0BD811D8||(t.ClusteringUsingOPTICSCAD9384DAA1042E78771F55A0BD811D8={}))}(i=t.visual||(t.visual={}))}(t=e.extensibility||(e.extensibility={}))}(powerbi||(powerbi={}));var powerbi;!function(e){var t;!function(t){var i;!function(t){t.ClusteringUsingOPTICSCAD9384DAA1042E78771F55A0BD811D8={name:\"ClusteringUsingOPTICSCAD9384DAA1042E78771F55A0BD811D8\",displayName:\"Clustering using OPTICS by MAQ Software\",\"class\":\"ClusteringUsingOPTICS\",version:\"3.0.5\",apiVersion:\"2.1.0\",create:function(t){return new e.extensibility.visual.ClusteringUsingOPTICSCAD9384DAA1042E78771F55A0BD811D8.ClusteringUsingOPTICS(t)},custom:!0}}(i=t.plugins||(t.plugins={}))}(t=e.visuals||(e.visuals={}))}(powerbi||(powerbi={}));",
    "css": ".visual-ClusteringUsingOPTICSCAD9384DAA1042E78771F55A0BD811D8 .rcv_autoScaleImageContainer{position:relative}.visual-ClusteringUsingOPTICSCAD9384DAA1042E78771F55A0BD811D8 .rcv_autoScaleImageContainer .rcv_autoScaleImage{max-width:100%;max-height:100%;position:absolute;top:50%;left:50%;transform:translateY(-50%) translateX(-50%);-webkit-transform:translateY(-50%) translateX(-50%)}",
    "iconBase64": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAAFEmlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDIgNzkuMTYwOTI0LCAyMDE3LzA3LzEzLTAxOjA2OjM5ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpIiB4bXA6Q3JlYXRlRGF0ZT0iMjAxNy0xMi0wNlQxNjowMjoyMSswNTozMCIgeG1wOk1vZGlmeURhdGU9IjIwMTctMTItMDZUMTY6MDY6NTUrMDU6MzAiIHhtcDpNZXRhZGF0YURhdGU9IjIwMTctMTItMDZUMTY6MDY6NTUrMDU6MzAiIGRjOmZvcm1hdD0iaW1hZ2UvcG5nIiBwaG90b3Nob3A6Q29sb3JNb2RlPSIzIiBwaG90b3Nob3A6SUNDUHJvZmlsZT0ic1JHQiBJRUM2MTk2Ni0yLjEiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6N2IxZTE0ZWMtMDEwOS1iYTQzLWJkZjYtZTRkZDNmMzM4MjdhIiB4bXBNTTpEb2N1bWVudElEPSJ4bXAuZGlkOjdiMWUxNGVjLTAxMDktYmE0My1iZGY2LWU0ZGQzZjMzODI3YSIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOjdiMWUxNGVjLTAxMDktYmE0My1iZGY2LWU0ZGQzZjMzODI3YSI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6N2IxZTE0ZWMtMDEwOS1iYTQzLWJkZjYtZTRkZDNmMzM4MjdhIiBzdEV2dDp3aGVuPSIyMDE3LTEyLTA2VDE2OjAyOjIxKzA1OjMwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgKFdpbmRvd3MpIi8+IDwvcmRmOlNlcT4gPC94bXBNTTpIaXN0b3J5PiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pu9KJ3QAAAIASURBVDiNrZTNaxNBGIefNGkzNgY/sCAexsSDIipGEBUqmnqq1IMevLb0JuxBD1K9hN68ePEynnoI/gF+XKogSA16kAqtB+vNJKNIIQW3Ji5TTY2HTsK63U2J+sLA7vvxvL+ZeXdjrVaL/2l9vRYYJe8ZJXNR8VgvCo2SRWACWAVywtGVYE4ipCjjTzRKpoFLQB4Ytu464IY1/QNoFVw2Sl4FDgEHgR3AO2DOrotAClgPA3a2bM9lwafgNvA1rAjYBRwQjr4ZDHQuRTh6EZgE1oA7XWDYWMIoeTYSaKFF4D5QDaOsp7ODq2OzhbXslf3AG+B6V+BWVs/PFH6JocNebqrwc+/wELBglLy1FTAZBexffvUUIN6ovu1ffl0DysBJo+Tn9mxuGhtgoKNopDg+UHnyMll+VAVIzU+X4o1PK+LDzJJNGQTGgG3AnFEyE7nl+khxvLn7yKiXm2qfGQA+GIAHzNrnG8LRbiSwr1GtAMSaXi2xsliLygO+A0fthW4a7BxwBniRmp8uxX5885IfHy7F62UvApYFngtHv287goNdAtLAM+BBF1VtGxWOnvA7/Aordh2z7+eBJvCFjdv02zVgJ3A32KEDFI52jZLngLxw9GOreh9wATgObLf5J4BTtmxPENjT78s2mWTja9LAaeFo95+AFpoB3CDsr4Hd7Dfi4LqYdx0jmQAAAABJRU5ErkJggg=="
  }
}